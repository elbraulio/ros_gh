id,body
9033,"<p>A list of stacks, packages, or tutorials related to hardware drivers.</p>
"
9036,"<p>Information on ROS packages.</p>
"
9037,"<p>Where to get started.</p>
"
9038,"<p>There's no Makefile in the root of ros-pkg!</p>
"
9039,"<p>I am getting errors when I type make.</p>
"
9040,"<p>I want to know what datatypes tf can work with natively.  </p>
"
9041,"<p>So I have been working on using IRI's segway library to implement a segway driver for ROS, and I have run into a situation where I don't know how to proceed.</p>

<p>IRI is setting up a port of their stuff for ROS, so at this point it is more educational for me.</p>

<p>So, the IRI segway library relies on some of their other libraries.</p>

<p>Here is the dependency Structure:</p>

<ul>
<li>My ROS Node depends on iri_segway_rmp200.</li>
<li>iri_segway_rmp200 depends on iricomms and iriutils.</li>
<li>iricomms depends on iriutils.</li>
</ul>

<p>All of the IRI stuff is in SVN and is LGPL licensed, my stuff can be considered MIT.  They are setup to build dynamically linked libraries (.so on linux and .dylib on osx).  </p>

<p>The way I see it there are a few ways to approach this setup in ROS: (Maybe there is a 4th, correct setup)</p>

<ol>
<li>Put a script in rosdep.yaml to (svn co; make; sudo make install) each of the libraries from IRI.
<ul>
<li>This is good because the libraries are installed and no further configuration is required, but requires root access</li>
<li>Also, they install Find&lt;lib&gt;.cmake files in the cmake shared Modules folder, which is nice</li>
</ul></li>
<li>Create a ROS pkg for each library and use rosmake to build them, using the svn_checkout.mk make script and patches to build and install them to the pkg dir
<ul>
<li>This is nice because the libraries are contained in the ros pkg</li>
<li>But, you need to export cpp flags to include and link directories</li>
<li>How do you handle runtime dynamic linking?</li>
</ul></li>
<li>Download/Distribute and build the libraries in your ROS pkg and statically link your node to the libraries
<ul>
<li>Doesn't allow multiple nodes to link to a single source for the libraries (build the libs for each node that uses them)</li>
</ul></li>
</ol>

<p>So here are my questions:</p>

<ol>
<li>What is the preferred method of build architecture?</li>
<li>How do you handle dynamic linking at runtime? (the .so file is in package A, and how does a binary in package B find it at runtime?) </li>
<li>How can you handle installing and referencing Find&lt;lib&gt;.cmake files that libraries have? (use manifext.xml's &lt;depend ...=""""/&gt; instead, is my guess)</li>
<li>What if any licensing concerns are there? (patches and static linking, etc)</li>
</ol>

<p>Sorry if some of these questions are silly, I am still learning these more complicated build systems (rosmake/cmake).</p>

<p>Thanks in advanced!</p>
"
9042,"<p> There should be some straightforward guidelines as to which one to pick. Also what is the scope of  <a href=""http://answers.ros.org"">answers.ros.org</a> , is it the same as ros-users? What about questions that would otherwise have been asked on ros-developers, ros-kinect, or pcl-users? </p>
"
9043,"<p>Generally, at what point does a project become large enough to justify the added time of writing a .xacro file (xml macro for generating URDF files) versus just using a hand-written URDF file?</p>
"
9044,"<p>I have a question which refers to a specific stack or package how should I tag it?  </p>
"
